{"name":"inherit.js","tagline":"A more elegant way to prototype","body":"inherit.js\r\n==========\r\n\r\nA more elegant way to prototype.\r\n\r\ninherit.js is a lightweight (3kb) wrapper for prototyping in js.\r\n\r\nIt combines function chaining with Python-inspired syntax\r\nto make object orientation in Javascript more manageable and easier to read.\r\n\r\nCompatibility\r\n-------------\r\n\r\ninherit.js is supported by all current versions of major browsers.\r\n\r\nInstallation\r\n------------\r\n\r\ninherit.js is currently only supported client-side, but expect node support soon. :)\r\n\r\nDownload inherit.min.js and include it on any page using\r\n\r\n```html\r\n<script src=\"path_to_my_scripts/inherit.min.js\"></script>\r\n```\r\n\r\nbefore you start using inherit-js code, and you're good to go!\r\n\r\nUsage\r\n-----\r\n\r\nUsing inherit.js is easy.\r\n\r\n```javascript\r\n$class('myClass')\r\n  \r\n  .var('myVar', 100)\r\n  \r\n  .def(\r\n    'myMethod',\r\n    function(x) {\r\n      return this.myVar++;\r\n    }\r\n  )\r\n    \r\n.class$;\r\n```\r\n\r\n\r\nThis will create a class ```$class.myClass``` with prototyped variable ```myVar``` and prototype method ```myMethod```.\r\n\r\n\r\n__NOTE__: ```.class$;``` might look like syntactic sugar, but actually has functional significance. Do not forget it!\r\n\r\n\r\n__All objects (classes) created this way will be stored in the global $class variable.__\r\n\r\n```javascript\r\n// parens are not necessary if we have no initialization variables\r\nvar test = new $class.myClass();\r\n\r\n// will print :: 100\r\nconsole.log(test.myVar);\r\n\r\n// increment test.myVar, return result;\r\ntest.myMethod();\r\n\r\n// will print :: 101\r\nconsole.log(test.myMethod());\r\n\r\n// myVar was incremented after it was returned, will print :: 102\r\nconsole.log(test.myVar);\r\n\r\n// new instance, will print :: 100\r\nvar test2 = new $class.myClass();\r\nconsole.log(test2.myVar);\r\n```\r\n\r\nWas it prototyped correctly? The ```instanceof``` operator will tell us...\r\n\r\n```javascript\r\n// will print :: true\r\nconsole.log(test instanceof $class.myClass);\r\n```\r\n\r\nInitialization\r\n--------------\r\n\r\ninherit.js supports an ```__init__``` magic method, which can take any number of arguments\r\n\r\n```javascript\r\n$class('clsInit')\r\n\r\n  .var('x', 0)\r\n  .var('y', 0)\r\n  \r\n  .def(\r\n    '__init__',\r\n    function(x, y) {\r\n      // x|0, y|0 not typos - force x, y to 32-bit signed ints by bitwise OR with 0.\r\n      this.x = x|0;\r\n      this.y = y|0;\r\n    }\r\n  )\r\n  \r\n.class$;\r\n```\r\n\r\nWhen we instantiate ```$class.clsInit```, we can now provide two arguments and have the newly created object's ```x``` and ```y``` values set.\r\n\r\n```javascript\r\nvar obj = new $class.clsInit(37,69);\r\n\r\n// will print :: [37, 69]\r\nconsole.log([obj.x, obj.y]);\r\n```\r\n\r\nInheritance\r\n-----------\r\n\r\ninherit.js also provides an easy way to inherit from other inherit.js objects using the ```.extends()``` function.\r\n\r\n```javascript\r\n$class('clsExtension')\r\n  .extends($class.clsInit)\r\n  \r\n  .def(\r\n    '__init__',\r\n    function(a) {\r\n      console.log('Extension initialized.');\r\n      $super(99,99);\r\n    }\r\n  )\r\n  \r\n.class$;\r\n```\r\n\r\nYou'll notice we have a ```$super()``` call in the ```__init__``` method.\r\n\r\n```$super()``` will automatically reference the parent method of the same name if it exists, otherwise it will return null.\r\n\r\n\r\nIf a parent object does not have a method of the same name, ```$super()``` will continue up the prototype tree to find the next method that has one, if it exists.\r\n\r\n\r\n__NOTE__: If you do not make a call to ```$super()```, child methods will override parent methods completely.\r\n\r\n```javascript\r\n// will print :: 'Extension initialized.'\r\nvar obj2 = new $class.clsExtension();\r\n\r\n// will print :: [99, 99]\r\nconsole.log([obj2.x, obj2.y]);\r\n```\r\n\r\nAnd what about ```instanceof```?\r\n\r\n```javascript\r\n// will print :: true\r\nconsole.log(test instanceof $class.clsExtension);\r\n\r\n// will also print :: true\r\nconsole.log(test instanceof $class.clsInit);\r\n// Hooray!\r\n```\r\n\r\nDebugging\r\n---------\r\n\r\nYou'll notice that you'll come across very hard-to-trace bugs when defining methods with inherit.js.\r\n\r\nDon't worry!\r\n\r\nJust call:\r\n```javascript\r\n$debug();\r\n```\r\n\r\nBefore defining your classes, and if you come across errors the class and method will be pointed out for you. :)\r\n\r\nPerformance testing\r\n-------------------\r\n\r\ninherit.js comes with a built in performance-testing function.\r\n\r\nAs inherit.js is largely a prototyping wrapper, there *should* be no decrease in performance associated with\r\nthe code you write, with the exception of methods that use ```$super()``` - expect them to take a few more nanoseconds. ;)\r\n(Test it yourself!)\r\n\r\n```javascript\r\n// Let's test a million times...\r\nvar iteration_count = 1000000;\r\n$test(function() { /* code to test */ }, 'My Test Name', iteration_count);\r\n```\r\n\r\nThis will output a nice little log in your console telling you performance statistics - operations per second, and time per operation in nanoseconds.\r\n\r\nThat's it!\r\n----------\r\n\r\nYou're all ready to use inherit.js. Go nuts! :)\r\n\r\nFeel free to contact me at keithwhor at gmail.com\r\n\r\n    ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}